# Everythings hosted off of b4t.to

# Best Practices:
# restart:always - This will make sure the container restarts when docker daemon
# restarts or the container exits. Can still stop the container with manual
# action, doesn't require unless-stopped (that just refers to not restarting the
# container if stopped after a daemon restart)
# HEALTHCHECK - Try to make a container healthy/unhealthy based on only the smallest
# testable unit. You can't do this at the domain level (eg, testing seafile.b4t.to)
# because traefik filters unhealthy containers...

# TODO: Setup email where service supports it (like seafile)
# TODO: Setup all logging collection
# TODO: Healthchecks
# * Some containers don't have curl, wget, iwr, or nc and would require custom
# dockerfile to do...
# https://docs.docker.com/compose/compose-file/#healthcheck
# TODO: Implement service specfic backup recommendations
# https://download.seafile.com/published/seafile-manual/docker/deploy%20seafile%20with%20docker.md
# TODO: Find alpines for relevant services

# Please pass in the following variables
# $EMAIL - Email for Traefik

# $ICECAST_PASSWORD - Just sonething strong and random, used by the icecast admin panel and stream connection
# $SPOTIFY_USERNAME
# $SPOTIFY_CLIENT_ID
# $SPOTIFY_CLIENT_SECRET
# $SOUNDCLOUD_TOKEN
# $YOUTUBE_KEY

# $SEAFILE_MYSQL_PASSWORD - Just something strong and random
# $SEAFILE_ADMIN_PASSWORD - Admin account password

# $TRAEFIK_HTPASSWD - The Traefik Dashboard Basic Auth Htpasswd

# $PORTAINER_HTPASSWD - The portainer admin password, without the username: part

# $DUPLICATI_GMAIL_EMAIL - User name for sending gmail notifications from duplicati
# $DUPLICATI_GMAIL_PASSWORD - Password for sending gmail notifications from duplicati

# $CLOUDFLARE_DDNS_B4T_TO_API_KEY - The API key for Cloudflare DDNS editting for b4t.to
#                                   Needs Zone:Zone:Read and Zone:DNS:Edit

# $BATTO_SCRIPT_AUTH - Key to authenticate cross container communications via 
# web services

version: "3.6"
services:
  # Mopidy + Icecast - My music streaming replacement
  # NOTE: Still super WIP
  # TODO: Fix the latency between playing the song and hearing it on the stream
  # (there seems to be a icecast configuration I can change for this about
  # buffering)
  # TODO: Some of the integrations don't work ;-;
  # TODO: Setup logging and hook up log scanner
  mopidy:
    image: wernight/mopidy:latest
    container_name: mopidy
    restart: always
    volumes:
      - ~/Dropbox/Music/NotOnSpotify:/var/lib/mopidy/media:ro #Local media files
      - /opt/batto-cave/mopidy-data:/var/lib/mopidy/local     #Local configurations
    ports:
      - 6600:6600 #MPD server for ncmpcpp
    #  - 6680:6680 #HTTP server for web client
    command: >-
      mopidy
      -o "audio/output=lamemp3enc ! shout2send async=false mount=mopidy ip=icecast port=8000 password=$ICECAST_PASSWORD"
      -o "spotify/username=$SPOTIFY_USERNAME"
      -o "spotify/password=$SPOTIFY_PASSWORD"
      -o "spotify/client_id=$SPOTIFY_CLIENT_ID"
      -o "spotify/client_secret=$SPOTIFY_CLIENT_SECRET"
      -o "soundcloud/auth_token=$SOUNDCLOUD_TOKEN"
      -o "youtube/youtube_api_key=$YOUTUBE_KEY"
    networks:
      - traefik-proxy
      - mopidy-icecast
    depends_on:
      - icecast
    labels:
      - "traefik.enable=true"
      # Mopidy exposes multiple ports, we just need the dashboard
      - "traefik.http.services.mopidy.loadbalancer.server.port=6680"
      - "traefik.http.routers.mopidy.rule=Host(`mopidy.b4t.to`)"
      - "traefik.http.routers.mopidy.tls.certresolver=cloudflarednsresolver"
      - "traefik.http.routers.mopidy.middlewares=http-compress"
  icecast:
    build: 
      context: icecast/
    container_name: icecast
    restart: always
    # ports:
    #  - 8000:8000 #Default icecast
    environment:
      ICECAST_SOURCE_PASSWORD: "$ICECAST_PASSWORD"
      ICECAST_RELAY_PASSWORD: "$ICECAST_PASSWORD"
      ICECAST_ADMIN_PASSWORD: "$ICECAST_PASSWORD"
      ICECAST_ADMIN_USERNAME: admin
    networks:
      - traefik-proxy
      - mopidy-icecast
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.icecast.rule=Host(`icecast.b4t.to`)"
      - "traefik.http.routers.icecast.tls.certresolver=cloudflarednsresolver"
      - "traefik.http.routers.icecast.middlewares=lan-only,http-compress"

  # Seafile - Dropbox replacement
  # https://download.seafile.com/published/seafile-manual/docker/deploy%20seafile%20with%20docker.md
  # TODO: I should come back to this and use gosu to run this stuff as non-root
  # or use another container that solves this
  # https://github.com/haiwen/seafile-docker/issues/86
  # TODO: Get the logs for this as well
  # TODO: seafile bundles nginx as well, and points everything at
  # that reverse proxy, would be nice to unbundle it? and let traefik handle it
  # https://forum.seafile.com/t/traefik-reverse-proxy/6142/5
  # TODO: seahub has issues with mixed content because of something with the avatars?
  # https://forum.seafile.com/t/avatar-in-share-dialog-missing/4179/15
  # TODO: Seafile config is currently in the data directory. It would be nice to put it in here
  # and version it. Separately I had to configure Seafdav (WebDAV) and seafile
  # to allow larger uploads in the conf files
  # https://download.seafile.com/published/seafile-manual/extension/webdav.md
  # You also need to fix the nginx config for webdav in 7.1 seafile
  # https://forum.seafile.com/t/webdav-not-working-with-nginx-in-front-of-seafile-pro-docker-setup/11696/2
  seafile-db:
    image: mariadb:10.1
    container_name: seafile-db
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: "$SEAFILE_MYSQL_PASSWORD"
      MYSQL_LOG_CONSOLE: "true"
    volumes:
      - /opt/batto-cave/seafile-mysql/db:/var/lib/mysql
    networks:
      - seafile-internal
    healthcheck:
      # Perform a select to check health
      test: ["CMD", "mysql", "--user=root", "--password=$SEAFILE_MYSQL_PASSWORD", "--execute=select 1"]
      interval: 5s
      timeout: 10s
      retries: 3

  seafile-memcached:
    image: memcached:1.5.6
    container_name: seafile-memcached
    restart: always
    entrypoint: memcached -m 256
    networks:
      - seafile-internal

  seafile:
    image: seafileltd/seafile-mc:latest
    container_name: seafile
    restart: always
    volumes:
      - /opt/batto-cave/seafile-data:/shared
   # ports:
   # None of these actually need to be exposed because
   # Nginx will hook them all up inside this container
   # (see TODO at top of seafile section)
   # So if you're putting traefik in front of the seafileltd container
   # you're actually pointing to NGinx which proxies to the original
   # services...
   #  - "80:80"
   #  - "443:443"
   #  - "8000:8000" #
   #  - "8082:8082" #seahub fileserver
    environment:
      DB_HOST: seafile-db
      DB_ROOT_PASSWD: "$SEAFILE_MYSQL_PASSWORD"
      TIME_ZONE: America/Detroit
      SEAFILE_ADMIN_EMAIL: cobertosrobertos@gmail.com
      SEAFILE_ADMIN_PASSWORD: "$SEAFILE_ADMIN_PASSWORD"
      SEAFILE_SERVER_LETSENCRYPT: "false"
    depends_on:
      - seafile-db
      - seafile-memcached
    networks:
      - traefik-proxy
      - seafile-internal
    labels:
      - "traefik.enable=true"
      - "traefik.http.services.seafile.loadbalancer.server.port=80"
      - "traefik.http.routers.seafile.entrypoints=https"
      - "traefik.http.routers.seafile.rule=Host(`seafile.b4t.to`)"
      - "traefik.http.routers.seafile.service=seafile"
      - "traefik.http.routers.seafile.tls.certresolver=cloudflarednsresolver"
      # - "traefik.http.routers.seafile.tls.domains.main=b4t.to"
      # - "traefik.http.routers.seafile.tls.domains.sans=*.b4t.to"
      - "traefik.http.routers.seafile.middlewares=http-compress"
      # Separately define without TLS rule above so that we can listen on HTTP
      # (traefik will stop listening when you define it)
      # Needs to have higher priority than https redirect catchall rule (priority
      # ~22 based on rule length)
      - "traefik.http.services.seafile-http.loadbalancer.server.port=80"
      - "traefik.http.routers.seafile-http.entrypoints=http"
      - "traefik.http.routers.seafile-http.priority=100"
      - "traefik.http.routers.seafile-http.service=seafile-http"
      - "traefik.http.routers.seafile-http.rule=Host(`seafile.b4t.to`)"
      - "traefik.http.routers.seafile-http.middlewares=http-compress"
    healthcheck:
      test: ["CMD", "curl", "--fail", "http://localhost:80"]
      interval: 30s
      timeout: 10s
      retries: 3

  # TODO:MAke a separate password
  statping-db:
    image: postgres:10
    container_name: statping-db
    restart: always
    networks:
      - statping-internal
    volumes:
      - /opt/batto-cave/statping-data:/var/lib/postgresql/data
    environment:
      POSTGRES_PASSWORD: $SEAFILE_MYSQL_PASSWORD
      POSTGRES_USER: statping
      POSTGRES_DB: statping
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U statping"]
      interval: 10s
      timeout: 5s
      retries: 5

  statping:
    image: statping/statping
    container_name: statping
    restart: always
    volumes:
      - /opt/batto-cave/statping:/app
    depends_on:
      - statping-db
    environment:
      DB_CONN: postgres
      DB_HOST: statping-db
      DB_USER: statping
      DB_PASS: $SEAFILE_MYSQL_PASSWORD
      DB_DATABASE: statping
      NAME: "Batto Ping"
      DESCRIPTION: "Keep an eye on all that important shit"
    networks:
      - traefik-proxy
      - statping-internal
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.statping.rule=Host(`statping.b4t.to`)"
      - "traefik.http.routers.statping.tls.certresolver=cloudflarednsresolver"
      - "traefik.http.routers.statping.middlewares=http-compress"

  portainer:
    image: portainer/portainer:latest
    container_name: portainer
    restart: always
    networks:
      - traefik-proxy
    # ports:
    #   - "8000:8000"
    #   - "9000:9000" # 9000 has the dashboard
    command:
      - "--admin-password=${PORTAINER_HTPASSWD}"
    volumes:
      - "/etc/localtime:/etc/localtime:ro" # Sync timezone information
      - "/var/run/docker.sock:/var/run/docker.sock:ro"
      - "/opt/batto-cave/portainer:/data"
    labels:
      - "traefik.enable=true"
      - "traefik.http.services.portainer.loadbalancer.server.port=9000"
      - "traefik.http.routers.portainer.rule=Host(`portainer.b4t.to`)"
      - "traefik.http.routers.portainer.tls.certresolver=cloudflarednsresolver"
      - "traefik.http.routers.portainer.middlewares=lan-only,http-compress"

  # Uses PHP, memcached and apache under the hood
  rss-bridge:
    image: rssbridge/rss-bridge:latest
    container_name: rss-bridge
    restart: always
    networks:
      - traefik-proxy
    volumes:
      - ./rss-bridge/whitelist.txt:/app/whitelist.txt
    # ports:
    #   - "3031:80"
    labels:
      - "traefik.enable=true"
      - "traefik.http.services.rss-bridge.loadbalancer.server.port=80"
      - "traefik.http.routers.rss-bridge.rule=Host(`rss-bridge.b4t.to`)"
      - "traefik.http.routers.rss-bridge.tls.certresolver=cloudflarednsresolver"
      - "traefik.http.routers.rss-bridge.middlewares=http-compress"

  # Fresh RSS
  freshrss-db:
    image: postgres
    restart: always
    container_name: freshrss-db
    networks:
      - freshrss-internal
    volumes:
      - /opt/batto-cave/freshrss-data:/var/lib/postgresql/data
    environment:
      POSTGRES_USER: freshrss
      POSTGRES_PASSWORD: freshrss
      POSTGRES_DB: freshrss
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U freshrss"]
      interval: 10s
      timeout: 5s
      retries: 5

  freshrss:
    image: freshrss/freshrss
    restart: always
    networks:
      - freshrss-internal
      - traefik-proxy
    #ports:
    #  - "80:80"
    depends_on:
      - freshrss-db
    volumes:
      - /opt/batto-cave/freshrss-app/data:/var/www/FreshRSS/data
      - /opt/batto-cave/freshrss-app/extensions:/var/www/FreshRSS/extensions
    environment:
      - CRON_MIN=*/20
      - TZ=America/Detroit
    labels:
      - "traefik.enable=true"
      - "traefik.http.services.freshrss.loadbalancer.server.port=80"
      - "traefik.http.routers.freshrss.rule=Host(`freshrss.b4t.to`)"
      - "traefik.http.routers.freshrss.tls.certresolver=cloudflarednsresolver"
      - "traefik.http.routers.freshrss.middlewares=http-compress"

  # Encrypted backup solution
  # You need to open the dashboard and configure the backup solution. For me this
  # involved setting up a new bucket in Backblaze B2, adding a new backup for
  # that new bucket with app key and ID, and telling Duplicati to backup /data-to-backup
  # TODO: Mount the tmp folder for more control over it (and preferably don't use the
  # SSD)
  # TODO: Fix volume name ;-; (dupicati)
  # TODO: Figure out how to pass in the encryption key
  # TODO: Figure out how to pass in the backup methods instead of relying
  # on manual setup (cause it should be able to parameterize) and duplicati
  # supports CLI)
  duplicati:
    build: 
      context: duplicati/
    container_name: duplicati
    restart: always
#    ports:
#      - "8200:8200"
    networks:
      - traefik-proxy
      - batto-svc-internal
    volumes:
      - "/opt/batto-cave/dupicati:/data"
      - "/opt/batto-cave:/data-to-backup:ro"
    labels:
      - "traefik.enable=true"
      - "traefik.http.services.duplicati.loadbalancer.server.port=8200"
      - "traefik.http.routers.duplicati.rule=Host(`duplicati.b4t.to`)"
      - "traefik.http.routers.duplicati.tls.certresolver=cloudflarednsresolver"
      - "traefik.http.routers.duplicati.middlewares=lan-only,http-compress"
    environment:
      BATTO_SCRIPT_AUTH: "$BATTO_SCRIPT_AUTH"
    command:
      # These get passed to /usr/bin/tini
      # https://github.com/krallin/tini
      - "/usr/bin/duplicati-server"
      - "--webservice-port=8200"
      # Without the flag set, you will get a "The host header sent by the client is not allowed"
      # error. Semicolon separated hostnames, * for everything, always allows IP
      # address and localhost directly.
      # It's meant to prevent DNS based attacks (DNS rebinding)
      - "--webservice-allowed-hostnames=duplicati.b4t.to"
      # - "--log-level=debug"
      # Custom configuration for sending mail for backups with Gmail for now
      # https://forum.duplicati.com/t/how-to-configure-automatic-email-notifications-via-gmail-for-every-backup-job/869
      - "--send-mail-url=smtp://smtp.gmail.com:587/?starttls=when-available"
      - "--send-mail-any-operation=true"
      - "--send-mail-subject=Duplicati %PARSEDRESULT%, %OPERATIONNAME% report for %backup-name%"
      - "--send-mail-to=cobertosrobertos@gmail.com"
      - "--send-mail-username=${DUPLICATI_GMAIL_EMAIL}"
      - "--send-mail-password=${DUPLICATI_GMAIL_PASSWORD}"
      - "--send-mail-from=b4t.to Duplicati <${DUPLICATI_GMAIL_EMAIL}>"
      - "--send-mail-level=Warning,Error,Fatal"
      # Only send errors, we should be collecting successes for analysis for logs
      # later anyway

      # The default server-datafolder did not work for me. I had to manually point
      # it do the Duplicati folder in the data directory (contrary to the docs)
      - "--server-datafolder=/data/Duplicati"

      # We need to run other things before duplicati does it's thing
      - "--run-script-before-required=/run-before-backup.sh"
    healthcheck:
      #lan-only, just check locally
      test: ["CMD", "curl", "--fail", "localhost:8200"]
      interval: 30s
      timeout: 10s
      retries: 3

  # This will require some extra configuration in wg0.conf in the
  # wireguard config. We need to add the subnet for our local
  # network to the AllowedIPs, add a suffix to the Address of the peer
  # (otherwise some clients complain), but otherwise it should work
  # out of the box
  # https://www.stavros.io/posts/how-to-configure-wireguard/
  wireguard:
    image: linuxserver/wireguard
    restart: always
    container_name: wireguard
    cap_add:
      - NET_ADMIN
      - SYS_MODULE
    environment:
      PUID: '1000'
      PGID: '1000'
      TZ: America/Detroit
      SERVERURL: 'b4t.to'
      SERVERPORT: '51820'
      PEERS: '1'
      #PEERDNS: auto #optional
      #INTERNAL_SUBNET=10.13.13.0 #optional
    volumes:
      - /opt/batto-cave/wireguard:/config
      - /lib/modules:/lib/modules
    ports:
      - 51820:51820/udp
    sysctls:
      - net.ipv4.conf.all.src_valid_mark=1

  # Networking
  # TODO: Split this into multiple files or something... this is getting bad...
  # TODO: Specify the TLS ciphers explicitly?
  # https://github.com/Holi0317/homeserver-compose/blob/master/traefik/build/config/tls.toml
  # If you're ever having trouble with certificates, make sure you're using the staging
  # CA to debug. Also you can delete part or all of the acme.json file and then restart
  # traefik to get certificates to regenerate manually
  traefik:
    image: traefik:v2.2
    container_name: traefik
    restart: always
    command:
      # I could also use a traefik.yml and mount it to 
      #   - ./traefik/traefik.yml:/etc/traefik/traefik.yml
      # but ehhhh, I'll do that if this really becomes unweildy

      - "--log.level=DEBUG"

      # Turn on dashboard, configured to use Basic Auth in this contains labels
      # https://docs.traefik.io/operations/dashboard/#secure-mode
      - "--api.dashboard=true" # Defaults to port 8080

      - "--providers.docker=true"
      - "--providers.docker.exposedbydefault=false"
      # This needs to be the FULL NETWORK NAME. If not, Traefil will sometimes work
      # and sometimes give a bad gateway for containers (randomly every run)
      # https://stackoverflow.com/a/46439598/2759427
      - "--providers.docker.network=batto-cave_traefik-proxy"

      - "--entrypoints.http.address=:80"
      - "--entrypoints.https.address=:443"

      - "--certificatesresolvers.cloudflarednsresolver.acme.email=cobertosrobertos@gmail.com"
      - "--certificatesresolvers.cloudflarednsresolver.acme.storage=/data/acme.json"
      - "--certificatesresolvers.cloudflarednsresolver.acme.caServer=https://acme-v02.api.letsencrypt.org/directory"
      # - "--certificatesresolvers.cloudflarednsresolver.acme.caServer=https://acme-staging-v02.api.letsencrypt.org/directory"
      - "--certificatesresolvers.cloudflarednsresolver.acme.dnschallenge.provider=cloudflare"
    volumes:
      - "/opt/batto-cave/traefik:/data"
      - "/var/run/docker.sock:/var/run/docker.sock:ro"
    ports:
      - "80:80"
      - "443:443"
    environment:
      CF_DNS_API_TOKEN: '${CLOUDFLARE_DDNS_B4T_TO_API_KEY}'
    networks:
      - traefik-proxy
    labels:
      - "traefik.enable=true"
      #== Middlewares ==
      # LAN IP only
      - "traefik.http.middlewares.lan-only.ipwhitelist.sourcerange=127.0.0.1/32, 192.168.0.0/24"
      # Gzip
      - "traefik.http.middlewares.http-compress.compress=true"
      # Basic auth
      - "traefik.http.middlewares.auth.basicauth.users=$TRAEFIK_HTPASSWD"
      # https redirect
      - "traefik.http.middlewares.https-redirect.redirectscheme.scheme=https"
      - "traefik.http.middlewares.https-redirect.redirectscheme.permanent=true"
      # Security - TODO: More research on a couple of these, like stsSeconds
      # https://github.com/Holi0317/homeserver-compose/blob/master/traefik/build/config/middlewares.toml
      #- "traefik.http.middlewares.secure_head.headers.accessControlAllowOrigin=null"
      #- "traefik.http.middlewares.secure_head.headers.sslRedirect=true"
      #- "traefik.http.middlewares.secure_head.headers.contentTypeNosniff=true"
      #- "traefik.http.middlewares.secure_head.headers.browserXssFilter=true"
      #- "traefik.http.middlewares.secure_head.headers.contentSecurityPolicy=upgrade-insecure-requests"
      #- "traefik.http.middlewares.secure_head.headers.stsSeconds=31536000"
      #- "traefik.http.middlewares.secure_head.headers.framedeny=true"
      #- "traefik.http.middlewares.secure_head.headers.customResponseHeaders.Referrer-Policy=no-referrer"
      #- "traefik.http.middlewares.secure_head.headers.customResponseHeaders.X-Powered-By=null"
      
      # Global redirect all http to https
      - "traefik.http.routers.http-catchall.rule=HostRegexp(`{any:.+}`)"
      - "traefik.http.routers.http-catchall.entrypoints=http"
      - "traefik.http.routers.http-catchall.middlewares=https-redirect"

      # == Traefik Dashboard config (traefik-ception) ==
      - "traefik.http.routers.api.rule=Host(`traefik.b4t.to`) || Host(`traefik.localhost`)"
      - "traefik.http.routers.api.service=api@internal"
      - "traefik.http.routers.api.middlewares=lan-only,auth"

  cloudflare-ddns-b4t-to:
    image: oznu/cloudflare-ddns
    container_name: cloudflare-ddns-b4t-to
    restart: always
    environment:
      API_KEY: '${CLOUDFLARE_DDNS_B4T_TO_API_KEY}'
      ZONE: 'b4t.to'
    healthcheck:
      #Check that the DNS resolves to this boxes external IP address
      test: ["CMD-SHELL", "[ $$(dig +short b4t.to) = $$(dig +short myip.opendns.com @resolver1.opendns.com) ]"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Special services that talk to Docker through the socket
  batto-svc:
    build:
      context: batto-svc/
    container_name: batto-svc
    restart: always
    ports:
      - 7998:7998
    volumes:
      - "/var/run/docker.sock:/var/run/docker.sock"
    environment:
      BATTO_SCRIPT_AUTH: '${BATTO_SCRIPT_AUTH}'
      SEAFILE_MYSQL_PASSWORD: '${SEAFILE_MYSQL_PASSWORD}'
    networks:
      - batto-svc-internal

networks:
  traefik-proxy:
  # Even though Docker will automatically create a bridge network for us, it's
  # better to create one ourselves
  # https://docs.docker.com/network/bridge/#differences-between-user-defined-bridges-and-the-default-bridge
  mopidy-icecast:
    internal: true
  seafile-internal:
    internal: true
  statping-internal:
    internal: true
  freshrss-internal:
    internal: true
  batto-svc-internal:
    internal: true

